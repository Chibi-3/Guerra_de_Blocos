<script>
/* ======= VARIÁVEIS E ELEMENTOS DOM ======= */
const getHostIdBtn = document.getElementById('getHostId');
const connectToHostBtn = document.getElementById('connectToHost');
const myPeerIdSpan = document.getElementById('my-peer-id');
const otherPeerIdInput = document.getElementById('other-peer-id');
const statusP = document.getElementById('status');
const connectionSetupDiv = document.getElementById('connection-setup');
const gameAreaDiv = document.getElementById('game-area');
const gameMessage = document.getElementById('game-message');
const endGameButtonsDiv = document.getElementById('end-game-buttons');
const playAgainBtn = document.createElement('button');
playAgainBtn.className = "w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-2 px-4 rounded-lg transition-colors";
playAgainBtn.textContent = "Jogar Novamente";
const copyIdBtn = document.getElementById('copyIdBtn');

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const countdownOverlay = document.getElementById('countdown-overlay');

let peer, conn;
let player, friend;
let platforms = [];
let cameraY = 0;
let gameOver = false;
let gameRunning = false;
let animationFrameId;
let isHost = false;

// variável que controla a próxima Y a ser gerada (mais "acima")
let nextPlatformY = 0;

const GRAVITY = 0.4, JUMP_FORCE = -10, PLAYER_SPEED = 5;
const PLAYER_WIDTH = 30, PLAYER_HEIGHT = 30;

/* ======= PEERJS / MULTIPLAYER ======= */
function initializeHost() {
    isHost = true;
    if (peer) peer.destroy();
    statusP.textContent = 'Iniciando...';
    peer = new Peer();
    peer.on('open', id => {
        statusP.textContent = 'Aguardando conexão do amigo...';
        myPeerIdSpan.textContent = id;
        getHostIdBtn.disabled = true;
        copyIdBtn.classList.remove('hidden');
    });
    peer.on('connection', setupConnection);
    peer.on('error', err => {
        statusP.innerHTML = `Erro de conexão: ${err && err.type ? err.type : err}. <br> Por favor, recarregue a página e tente novamente.`;
    });
}

function connectToPeer() {
    isHost = false;
    const hostId = otherPeerIdInput.value.trim();
    if (!hostId) { alert('Insira o ID do Host.'); return; }
    if (peer) peer.destroy();
    peer = new Peer();
    peer.on('open', () => {
        statusP.textContent = `Tentando conectar ao Host: ${hostId}...`;
        const newConnection = peer.connect(hostId, { reliable: true });
        setupConnection(newConnection);
    });
    peer.on('error', err => {
        statusP.innerHTML = `Erro: ${err && err.type ? err.type : err}. <br>Verifique o ID ou tente novamente.`;
    });
}

function setupConnection(newConnection) {
    if (conn) conn.close();
    conn = newConnection;
    conn.on('open', () => {
        statusP.textContent = `Conectado a: ${conn.peer}`;
        connectionSetupDiv.classList.add('hidden');
        gameAreaDiv.classList.remove('hidden');
        // host inicia jogo e envia init; convidado espera o init do host
        if (isHost) initGame(true);
    });
    conn.on('data', handleData);
    conn.on('close', resetToLobby);
}

function handleData(data) {
    if (!data || !data.type) return;
    switch (data.type) {
        case 'init':
            // convidado recebe plataformas iniciais e nextY
            platforms = Array.isArray(data.platforms) ? data.platforms.slice() : [];
            nextPlatformY = typeof data.nextY === 'number' ? data.nextY : nextPlatformY;
            initGame(false);
            break;
        case 'new_plats':
            if (Array.isArray(data.platforms)) platforms.push(...data.platforms);
            if (typeof data.nextY === 'number') nextPlatformY = data.nextY;
            break;
        case 'pos':
            if (!friend) {
                friend = { x: 0, y: 0, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, alive: true, color: isHost ? 'tomato' : 'royalblue' };
            }
            friend.x = data.x; friend.y = data.y; friend.alive = data.alive;
            break;
        case 'dead':
            if (!friend) friend = { x:0,y:0,width:PLAYER_WIDTH,height:PLAYER_HEIGHT,alive:false };
            friend.alive = false;
            if (player && player.alive) endGame(true);
            break;
        case 'reset':
            initGame(isHost);
            break;
    }
}

function resetToLobby() {
    statusP.textContent = 'Conexão perdida.';
    gameAreaDiv.classList.add('hidden');
    connectionSetupDiv.classList.remove('hidden');
    getHostIdBtn.disabled = false;
    copyIdBtn.classList.add('hidden');
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
}

/* ======= GERAÇÃO DE PLATAFORMAS (controlada) ======= */
/*
  Coordenadas: y cresce para baixo (0 top). 
  nextPlatformY guarda o Y da próxima linha "acima" que precisamos gerar (será menor que 0 à medida que subimos).
*/
function addPlatforms(startY, numRows) {
    const newPlats = [];
    const halfWidth = canvas.width / 2;
    const platWidth = 100;
    let currentY = startY;
    const spacing = 120;
    const margin = 30;

    for (let i = 0; i < numRows; i++) {
        // esquerda
        newPlats.push({
            x: Math.random() * (halfWidth - platWidth - margin * 2) + margin,
            y: Math.round(currentY),
            width: platWidth,
            height: 20
        });
        // direita
        newPlats.push({
            x: halfWidth + Math.random() * (halfWidth - platWidth - margin * 2) + margin,
            y: Math.round(currentY + (Math.random() * 40 - 20)),
            width: platWidth,
            height: 20
        });
        currentY -= spacing;
    }
    // currentY agora aponta para a próxima linha acima que ainda não foi gerada
    nextPlatformY = Math.round(currentY);
    return newPlats;
}

/* ======= INICIALIZAÇÃO DO JOGO ======= */
function initGame(isInitiator = true) {
    // dimensiona canvas de acordo com container
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width || 600;
    canvas.height = 500;

    // reset variáveis
    gameOver = false;
    gameRunning = false;
    cameraY = 0;
    gameMessage.textContent = '';
    endGameButtonsDiv.innerHTML = '';

    const halfWidth = canvas.width / 2;
    const startX_P1 = (halfWidth / 2) - (PLAYER_WIDTH / 2);
    const startX_P2 = halfWidth + (halfWidth / 2) - (PLAYER_WIDTH / 2);

    player = { x: isHost ? startX_P1 : startX_P2, y: canvas.height - 100, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, color: isHost ? 'royalblue' : 'tomato', alive: true };
    friend = { x: isHost ? startX_P2 : startX_P1, y: canvas.height - 100, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, color: isHost ? 'tomato' : 'royalblue', alive: true };

    // host gera o mundo inicial e envia ao convidado (se conectado)
    if (isInitiator) {
        platforms = addPlatforms(canvas.height - 50, 12); // gera algumas fileiras iniciais
        if (conn && conn.open) {
            conn.send({ type: 'init', platforms: platforms, nextY: nextPlatformY });
        }
    }

    if (animationFrameId) cancelAnimationFrame(animationFrameId);

    // contagem regressiva
    let count = 3;
    countdownOverlay.style.display = 'flex';
    countdownOverlay.textContent = count;
    const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownOverlay.textContent = count;
        } else {
            clearInterval(countdownInterval);
            countdownOverlay.textContent = 'VAI!';
            setTimeout(() => {
                countdownOverlay.style.display = 'none';
                gameRunning = true;
                gameLoop();
            }, 450);
        }
    }, 1000);
}

/* ======= CONTROLES ======= */
const keys = {};
window.addEventListener('keydown', (e) => { keys[e.key] = true; });
window.addEventListener('keyup', (e) => { keys[e.key] = false; });

/* ======= UPDATE DO JOGO ======= */
function update() {
    if (gameOver || !gameRunning) return;
    if (!player) return;

    // Geração infinita controlada: quando nextPlatformY estiver próximo do topo visível, gera mais (só host gera)
    const genThreshold = cameraY - canvas.height * 1.2; // quando nextPlatformY > genThreshold gera
    if (isHost && nextPlatformY > genThreshold) {
        const newPlats = addPlatforms(nextPlatformY, 6);
        platforms.push(...newPlats);
        if (conn && conn.open) conn.send({ type: 'new_plats', platforms: newPlats, nextY: nextPlatformY });
    }

    // limpeza de plataformas fora da faixa visível (para não lotar memória)
    const keepTop = cameraY - canvas.height * 3;
    const keepBottom = cameraY + canvas.height * 2;
    platforms = platforms.filter(p => p.y > keepTop && p.y < keepBottom);

    // movimentos do jogador
    if (keys['ArrowLeft']) player.x -= PLAYER_SPEED;
    if (keys['ArrowRight']) player.x += PLAYER_SPEED;
    if ((keys['ArrowUp'] || keys[' ']) && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
    }

    player.vy += GRAVITY;
    player.y += player.vy;
    player.onGround = false;

    // colisões com plataformas
    for (let plat of platforms) {
        if (player.x < plat.x + plat.width && player.x + player.width > plat.x) {
            // colisão "de cima" - checa aproximação
            if (player.y + player.height > plat.y && player.y + player.height - player.vy <= plat.y && player.vy >= 0) {
                player.onGround = true;
                player.y = plat.y - player.height;
                player.vy = 0;
            }
        }
    }

    // limites horizontais por zona
    const halfWidth = canvas.width / 2;
    const margin = 5;
    if (isHost) {
        if (player.x < margin) player.x = margin;
        if (player.x + player.width > halfWidth - margin) player.x = halfWidth - player.width - margin;
    } else {
        if (player.x < halfWidth + margin) player.x = halfWidth + margin;
        if (player.x + player.width > canvas.width - margin) player.x = canvas.width - player.width - margin;
    }

    // CÂMERA: segue o jogador quando ele sobe acima de um limiar
    const followThreshold = cameraY + canvas.height * 0.4;
    if (player.y < followThreshold) {
        // sobe a câmera para manter o jogador no threshold
        cameraY = player.y - canvas.height * 0.4;
    }

    // morte por cair para baixo da tela visível
    if (player.y > cameraY + canvas.height) {
        player.alive = false;
        if (conn && conn.open) conn.send({ type: 'dead' });
        endGame(false);
    }

    // envia posição ao amigo (se conectado)
    if (conn && conn.open) {
        conn.send({ type: 'pos', x: player.x, y: player.y, alive: player.alive });
    }
}

/* ======= DESENHO ======= */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(0, -cameraY); // aplica câmera

    // linha divisória
    ctx.strokeStyle = '#4a5568';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, -100000);
    ctx.lineTo(canvas.width / 2, 100000);
    ctx.stroke();

    // plataformas
    ctx.fillStyle = '#63b3ed';
    platforms.forEach(plat => ctx.fillRect(plat.x, plat.y, plat.width, plat.height));

    // jogadores
    if (player && player.alive) {
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.width, player.height);
    }
    if (friend && friend.alive) {
        ctx.fillStyle = friend.color;
        ctx.fillRect(friend.x, friend.y, friend.width, friend.height);
    }

    ctx.restore();
}

/* ======= LOOP PRINCIPAL ======= */
function gameLoop() {
    update();
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
}

/* ======= FIM DE JOGO ======= */
function endGame(iWon) {
    if (gameOver) return;
    gameOver = true;
    gameRunning = false;
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    gameMessage.textContent = iWon ? "VOCÊ VENCEU!" : "Você perdeu...";
    gameMessage.style.color = iWon ? '#48bb78' : '#f56565';
    endGameButtonsDiv.innerHTML = '';
    if (isHost) endGameButtonsDiv.appendChild(playAgainBtn);
}

/* ======= EVENTOS / BOTOES ======= */
getHostIdBtn.addEventListener('click', initializeHost);
connectToHostBtn.addEventListener('click', connectToPeer);
playAgainBtn.addEventListener('click', () => {
    if (conn && conn.open) conn.send({type: 'reset'});
    initGame(isHost);
});
copyIdBtn.addEventListener('click', () => {
    const id = myPeerIdSpan.textContent;
    navigator.clipboard.writeText(id).then(() => {
        const feedback = document.createElement('div');
        feedback.textContent = 'Copiado!';
        feedback.className = 'copied-feedback';
        copyIdBtn.parentElement.appendChild(feedback);
        setTimeout(() => {
            feedback.remove();
        }, 2000);
    }).catch(err => console.error('Erro ao copiar ID: ', err));
});
</script>
