<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guerra de Blocos: Arena Vertical</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Biblioteca para gerar sons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0a0a0a; }
        #game-container { position: relative; }
        canvas {
            background-color: #1a202c;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #countdown-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 15px black;
            z-index: 10;
        }
        .hud {
            position: absolute;
            top: 10px;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.4);
            text-shadow: 1px 1px 2px black;
        }
        #player-hud { left: 5%; }
        #friend-hud { right: 5%; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-lg shadow-xl p-6 space-y-6">
        <h1 id="game-title" class="text-3xl font-bold text-center text-cyan-400">Guerra de Blocos: Arena Vertical</h1>

        <!-- Seção de Conexão -->
        <div id="connection-setup" class="bg-gray-700 p-4 rounded-lg">
            <h2 class="text-xl font-semibold mb-2">1. Conexão</h2>
            <p class="text-sm text-gray-400 mb-4">Um jogador deve ser o "Host". O outro se conecta a ele usando o ID.</p>
            
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <button id="getHostId" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Ser o Host</button>
                    <div class="mt-2 flex items-center justify-between">
                         <p class="text-sm">Seu ID: <strong id="my-peer-id" class="text-yellow-400 select-all">Aguardando...</strong></p>
                    </div>
                </div>
                <div class="flex-1">
                    <input type="text" id="other-peer-id" placeholder="Cole o ID do Host aqui" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="connectToHost" class="w-full mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Conectar ao Host</button>
                </div>
            </div>
            <p id="status" class="text-center mt-4 text-gray-400">Status: Desconectado</p>
        </div>

        <!-- Seção do Jogo -->
        <div id="game-area" class="hidden w-full">
            <div id="game-message" class="text-center mb-4 text-2xl font-bold h-8"></div>
            <div id="game-container">
                <canvas id="gameCanvas"></canvas>
                <div id="countdown-overlay">3</div>
                <div id="player-hud" class="hud" style="display: none;"></div>
                <div id="friend-hud" class="hud" style="display: none;"></div>
            </div>
             <div id="end-game-buttons" class="flex gap-4 mt-4"></div>
        </div>
    </div>

    <script>
    // --- CONFIGURAÇÃO E VARIÁVEIS ---
    const getHostIdBtn = document.getElementById('getHostId');
    const connectToHostBtn = document.getElementById('connectToHost');
    const myPeerIdSpan = document.getElementById('my-peer-id');
    const otherPeerIdInput = document.getElementById('other-peer-id');
    const statusP = document.getElementById('status');
    const connectionSetupDiv = document.getElementById('connection-setup');
    const gameAreaDiv = document.getElementById('game-area');
    const gameMessage = document.getElementById('game-message');
    const endGameButtonsDiv = document.getElementById('end-game-buttons');
    const playAgainBtn = document.createElement('button');
    playAgainBtn.className = "w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-2 px-4 rounded-lg transition-colors";
    playAgainBtn.textContent = "Jogar Novamente";

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const countdownOverlay = document.getElementById('countdown-overlay');
    const playerHud = document.getElementById('player-hud');
    const friendHud = document.getElementById('friend-hud');

    let peer, conn;
    let player, friend;
    let platforms = [], interactables = [], particles = [], stars = [];
    let cameraY = 0;
    let gameOver = false, gameRunning = false;
    let animationFrameId;
    let isHost = false;

    const GRAVITY = 0.4, PLAYER_SPEED = 5, PLAYER_WIDTH = 30, PLAYER_HEIGHT = 30;
    let JUMP_FORCE = -10, CAMERA_SPEED = 0.7;

    // --- EFEITOS SONOROS (TONE.JS) ---
    let soundStarted = false;
    const synth = new Tone.Synth().toDestination();
    const jumpSound = () => { if(soundStarted) synth.triggerAttackRelease("C4", "8n"); };
    const powerupSound = () => { if(soundStarted) synth.triggerAttackRelease("G5", "8n"); };
    const winSound = () => { if(soundStarted) synth.triggerAttackRelease("C5", "4n", Tone.now()); synth.triggerAttackRelease("G5", "4n", Tone.now() + 0.2); synth.triggerAttackRelease("C6", "4n", Tone.now() + 0.4); };
    const loseSound = () => { if(soundStarted) synth.triggerAttackRelease("C3", "4n"); };

    document.body.addEventListener('click', async () => {
        if (!soundStarted) {
            await Tone.start();
            soundStarted = true;
            console.log('Audio context started');
        }
    }, { once: true });


    // --- LÓGICA DE CONEXÃO (PEERJS) ---
    function initializeHost() {
        isHost = true;
        if (peer) peer.destroy();
        statusP.textContent = 'Iniciando...';
        peer = new Peer();
        peer.on('open', id => {
            statusP.textContent = 'Aguardando conexão do amigo...';
            myPeerIdSpan.textContent = id;
            getHostIdBtn.disabled = true;
        });
        peer.on('connection', setupConnection);
        peer.on('error', err => { statusP.innerHTML = `Erro: ${err.type}. <br> Recarregue a página e tente novamente.`; });
    }

    function connectToPeer() {
        isHost = false;
        const hostId = otherPeerIdInput.value.trim();
        if (!hostId) { alert('Insira o ID do Host.'); return; }
        if (peer) peer.destroy();
        peer = new Peer();
        peer.on('open', () => {
            statusP.textContent = `Tentando conectar ao Host: ${hostId}...`;
            const newConnection = peer.connect(hostId, { reliable: true });
            setupConnection(newConnection);
        });
        peer.on('error', err => { statusP.innerHTML = `Erro: ${err.type}. <br>Verifique o ID ou tente novamente.`; });
    }

    function setupConnection(newConnection) {
        if (conn) conn.close();
        conn = newConnection;
        conn.on('open', () => {
            statusP.textContent = `Conectado a: ${conn.peer}`;
            connectionSetupDiv.classList.add('hidden');
            gameAreaDiv.classList.remove('hidden');
            if (isHost) initGame();
        });
        conn.on('data', handleData);
        conn.on('close', resetToLobby);
    }
    
    function handleData(data) {
        switch (data.type) {
            case 'init':
                platforms = data.platforms;
                interactables = data.interactables;
                initGame(false);
                break;
            case 'pos':
                friend.x = data.x;
                friend.y = data.y;
                friend.alive = data.alive;
                break;
            case 'dead':
                friend.alive = false;
                if (player.alive) endGame(true);
                break;
            case 'reset':
                initGame(isHost);
                break;
            case 'powerup_effect':
                applyEffectToPlayer(data.effect);
                break;
        }
    }
    
    function resetToLobby() {
        statusP.textContent = 'Conexão perdida.';
        gameAreaDiv.classList.add('hidden');
        connectionSetupDiv.classList.remove('hidden');
        getHostIdBtn.disabled = false;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
    }
    
    // --- LÓGICA DO JOGO ---
    function generateLevel() {
        const plats = [], inters = [];
        const halfWidth = canvas.width / 2;
        const platWidth = 100;

        const createPlat = (side, y) => {
            const x = side === 'left' 
                ? Math.random() * (halfWidth - platWidth - 20) + 10
                : halfWidth + Math.random() * (halfWidth - platWidth - 20) + 10;
            
            const type = Math.random() > 0.9 ? 'fake' : 'normal'; // 10% de chance de ser falsa
            plats.push({ x, y, width: platWidth, height: 20, type });

            // Chance de gerar um power-up
            if (type === 'normal' && Math.random() > 0.85) {
                const powerupTypes = ['jump_boost', 'speed_boost', 'freeze_opponent'];
                const powerupType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                inters.push({ x: x + platWidth / 2, y: y - 20, type: powerupType, radius: 10, collected: false });
            }
        };

        // Plataformas iniciais
        plats.push({ x: halfWidth / 2 - platWidth / 2, y: canvas.height - 50, width: platWidth, height: 20, type: 'normal' });
        plats.push({ x: halfWidth + (halfWidth / 2 - platWidth / 2), y: canvas.height - 50, width: platWidth, height: 20, type: 'normal' });

        for (let i = 1; i < 100; i++) {
            const yPos = canvas.height - 50 - (i * 120);
            createPlat('left', yPos);
            createPlat('right', yPos + (Math.random() * 60 - 30));
        }
        platforms = plats;
        interactables = inters;
    }

    function createStars() {
        stars = [];
        for(let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 5, // Espalha as estrelas bem pra cima
                radius: Math.random() * 1.5
            });
        }
    }

    function initGame(isInitiator = true) {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = 500;

        gameOver = false; gameRunning = false; cameraY = 0;
        gameMessage.textContent = '';
        endGameButtonsDiv.innerHTML = '';
        playerHud.style.display = 'none';
        friendHud.style.display = 'none';

        const halfWidth = canvas.width / 2;
        const startX = isHost ? halfWidth / 2 : halfWidth + halfWidth / 2;
        player = { x: startX, y: canvas.height - 100, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, color: isHost ? 'royalblue' : 'tomato', alive: true, effects: {}, frozen: false };
        friend = { x: 0, y: 0, alive: true };
        
        if (isInitiator) {
            generateLevel();
            createStars();
            conn.send({ type: 'init', platforms, interactables });
        }
        
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        
        let count = 3;
        countdownOverlay.style.display = 'flex';
        countdownOverlay.textContent = count;
        
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) countdownOverlay.textContent = count;
            else {
                clearInterval(countdownInterval);
                countdownOverlay.textContent = 'VAI!';
                winSound();
                setTimeout(() => {
                    countdownOverlay.style.display = 'none';
                    gameRunning = true;
                    gameLoop();
                }, 500);
            }
        }, 1000);
    }

    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });

    function handlePlayerMovement() {
        if (player.frozen) return;
        const currentSpeed = player.effects.speed_boost ? PLAYER_SPEED * 1.5 : PLAYER_SPEED;
        if (keys['ArrowLeft']) player.x -= currentSpeed;
        if (keys['ArrowRight']) player.x += currentSpeed;
        if ((keys['ArrowUp'] || keys[' ']) && player.onGround) {
            player.vy = player.effects.jump_boost ? JUMP_FORCE * 1.5 : JUMP_FORCE;
            player.onGround = false;
            jumpSound();
            createParticles(player.x + player.width / 2, player.y + player.height, 5, '#ffffff');
        }
    }

    function handlePhysicsAndCollisions() {
        player.vy += GRAVITY;
        player.y += player.vy;
        player.onGround = false;

        platforms.forEach(plat => {
            if (player.x < plat.x + plat.width && player.x + player.width > plat.x &&
                player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy && player.vy >= 0) {
                if (plat.type === 'fake') {
                    plat.y += 5000; // Manda pra longe
                } else {
                    player.onGround = true;
                    player.y = plat.y - player.height;
                    player.vy = 0;
                }
            }
        });

        interactables.forEach(item => {
            if (!item.collected) {
                const dist = Math.hypot(player.x + player.width/2 - item.x, player.y + player.height/2 - item.y);
                if (dist < player.width/2 + item.radius) {
                    item.collected = true;
                    powerupSound();
                    if (item.type === 'freeze_opponent') {
                        conn.send({ type: 'powerup_effect', effect: { type: 'freeze' } });
                    } else {
                        applyEffectToPlayer({ type: item.type });
                    }
                }
            }
        });
        
        const halfWidth = canvas.width / 2;
        const limitLeft = isHost ? 0 : halfWidth;
        const limitRight = isHost ? halfWidth : canvas.width;
        if (player.x < limitLeft) player.x = limitLeft;
        if (player.x + player.width > limitRight) player.x = limitRight - player.width;
    }

    function applyEffectToPlayer(effect) {
        let duration = 5000; // 5 segundos para a maioria
        let hudText = '';

        if (effect.type === 'jump_boost') {
            player.effects.jump_boost = true;
            hudText = 'Super Pulo!';
        } else if (effect.type === 'speed_boost') {
            player.effects.speed_boost = true;
            hudText = 'Super Velocidade!';
        } else if (effect.type === 'freeze') {
            player.frozen = true;
            duration = 2000; // 2 segundos
            hudText = 'CONGELADO!';
        }

        updateHud(playerHud, hudText, duration / 1000);

        setTimeout(() => {
            if (effect.type === 'jump_boost') player.effects.jump_boost = false;
            if (effect.type === 'speed_boost') player.effects.speed_boost = false;
            if (effect.type === 'freeze') player.frozen = false;
        }, duration);
    }
    
    function updateHud(hudElement, text, duration) {
        if (!text) {
            hudElement.style.display = 'none';
            return;
        }
        hudElement.style.display = 'block';
        let timeLeft = duration;
        hudElement.textContent = `${text} (${timeLeft}s)`;
        
        const interval = setInterval(() => {
            timeLeft--;
            if (timeLeft > 0) {
                hudElement.textContent = `${text} (${timeLeft}s)`;
            } else {
                clearInterval(interval);
                hudElement.style.display = 'none';
            }
        }, 1000);
    }


    function update() {
        if (gameOver || !gameRunning) return;
        handlePlayerMovement();
        handlePhysicsAndCollisions();
        cameraY += CAMERA_SPEED;
        if (player.y > cameraY + canvas.height) {
            player.alive = false;
            conn.send({ type: 'dead' });
            endGame(false);
        }
        if (conn && conn.open) {
            conn.send({ type: 'pos', x: player.x, y: player.y, alive: player.alive });
        }
    }
    
    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 30,
                color
            });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(0, -cameraY);

        // Fundo de estrelas com parallax
        ctx.fillStyle = 'white';
        stars.forEach(star => {
            const screenY = star.y - cameraY * 0.5; // Efeito parallax
            ctx.beginPath();
            ctx.arc(star.x, screenY, star.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        // Linha divisória
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, -100000);
        ctx.lineTo(canvas.width / 2, 100000);
        ctx.stroke();

        // Plataformas
        platforms.forEach(plat => {
            ctx.fillStyle = plat.type === 'fake' ? 'rgba(255, 100, 100, 0.5)' : '#63b3ed';
            ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
        });

        // Interactables (Power-ups)
        interactables.forEach(item => {
            if (!item.collected) {
                ctx.save();
                ctx.translate(item.x, item.y);
                ctx.scale(1 + Math.sin(Date.now() / 200) * 0.1, 1 + Math.sin(Date.now() / 200) * 0.1);
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                if (item.type === 'jump_boost') { ctx.fillText('👟', -item.radius, item.radius); }
                else if (item.type === 'speed_boost') { ctx.fillText('⚡', -item.radius, item.radius); }
                else if (item.type === 'freeze_opponent') { ctx.fillText('❄️', -item.radius, item.radius); }
                ctx.fill();
                ctx.restore();
            }
        });

        // Jogadores
        if (player.alive) {
            ctx.fillStyle = player.frozen ? '#add8e6' : player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
        if (friend.alive) {
            ctx.fillStyle = friend.color;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(friend.x, friend.y, PLAYER_WIDTH, PLAYER_HEIGHT);
            ctx.globalAlpha = 1.0;
        }
        
        // Partículas
        particles.forEach((p, index) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            ctx.globalAlpha = p.life / 30;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
            if (p.life <= 0) particles.splice(index, 1);
        });
        ctx.globalAlpha = 1.0;

        ctx.restore();
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function endGame(iWon) {
        if (gameOver) return;
        gameOver = true;
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        gameMessage.textContent = iWon ? "VOCÊ VENCEU!" : "Você perdeu...";
        if (iWon) winSound(); else loseSound();
        
        endGameButtonsDiv.innerHTML = '';
        if(isHost) endGameButtonsDiv.appendChild(playAgainBtn);
    }

    // --- EVENT LISTENERS ---
    getHostIdBtn.addEventListener('click', initializeHost);
    connectToHostBtn.addEventListener('click', connectToPeer);
    playAgainBtn.addEventListener('click', () => {
        conn.send({type: 'reset'});
        initGame(true);
    });
    </script>
</body>
</html>
