<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guerra de Blocos: A Queda Infinita</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #game-container { position: relative; }
        canvas {
            background-color: #2d3748; /* Fundo azul-acinzentado */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #countdown-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: none; /* Começa escondido */
            justify-content: center;
            align-items: center;
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 15px black;
            z-index: 10;
        }
        .copied-feedback {
            position: absolute; bottom: 100%; left: 50%;
            transform: translateX(-50%); background-color: #2dce89;
            color: white; padding: 4px 8px; border-radius: 4px;
            font-size: 12px; white-space: nowrap;
        }
        .hud {
            position: absolute;
            top: 10px;
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px black;
        }
        #player-score { left: 20px; }
        #friend-score { right: 20px; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-lg shadow-xl p-6 space-y-6">
        <h1 id="game-title" class="text-3xl font-bold text-center text-cyan-400">Guerra de Blocos: A Queda Infinita</h1>

        <!-- Seção de Conexão -->
        <div id="connection-setup" class="bg-gray-700 p-4 rounded-lg">
            <h2 class="text-xl font-semibold mb-2">1. Conexão</h2>
            <p class="text-sm text-gray-400 mb-4">Um jogador deve ser o "Host". O outro se conecta a ele usando o ID.</p>
            
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <button id="getHostId" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Ser o Host</button>
                    <div class="mt-2 flex items-center justify-between">
                         <p class="text-sm">Seu ID: <strong id="my-peer-id" class="text-yellow-400 select-all">Aguardando...</strong></p>
                         <div class="relative">
                            <button id="copyIdBtn" class="hidden bg-gray-600 hover:bg-gray-500 text-white text-xs font-bold py-1 px-3 rounded-lg transition-colors">Copiar</button>
                         </div>
                    </div>
                </div>
                <div class="flex-1">
                    <input type="text" id="other-peer-id" placeholder="Cole o ID do Host aqui" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <button id="connectToHost" class="w-full mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Conectar ao Host</button>
                </div>
            </div>
            <p id="status" class="text-center mt-4 text-gray-400">Status: Desconectado</p>
        </div>

        <!-- Seção do Jogo -->
        <div id="game-area" class="hidden w-full">
            <div id="game-message" class="text-center mb-4 text-2xl font-bold h-8"></div>
            <div id="game-container">
                <canvas id="gameCanvas"></canvas>
                <div id="countdown-overlay">3</div>
                <div id="player-score" class="hud">P1: 0</div>
                <div id="friend-score" class="hud">P2: 0</div>
            </div>
             <div id="end-game-buttons" class="flex gap-4 mt-4"></div>
        </div>
    </div>

    <script>
    // --- CONFIGURAÇÃO INICIAL E VARIÁVEIS ---
    const getHostIdBtn = document.getElementById('getHostId');
    const connectToHostBtn = document.getElementById('connectToHost');
    const myPeerIdSpan = document.getElementById('my-peer-id');
    const otherPeerIdInput = document.getElementById('other-peer-id');
    const statusP = document.getElementById('status');
    const connectionSetupDiv = document.getElementById('connection-setup');
    const gameAreaDiv = document.getElementById('game-area');
    const gameMessage = document.getElementById('game-message');
    const endGameButtonsDiv = document.getElementById('end-game-buttons');
    const playAgainBtn = document.createElement('button');
    playAgainBtn.className = "w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-2 px-4 rounded-lg transition-colors";
    playAgainBtn.textContent = "Jogar Novamente";
    const copyIdBtn = document.getElementById('copyIdBtn');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const countdownOverlay = document.getElementById('countdown-overlay');
    const playerScoreHud = document.getElementById('player-score');
    const friendScoreHud = document.getElementById('friend-score');

    let peer, conn;
    let player, friend;
    let platforms = [];
    let gameOver = false;
    let gameRunning = false;
    let animationFrameId;
    let isHost = false;

    const GRAVITY = 0.5, JUMP_FORCE = -11, PLAYER_SPEED = 5;
    const PLAYER_WIDTH = 30, PLAYER_HEIGHT = 30;
    let PLATFORM_SPEED_INITIAL = 1.8;
    let PLATFORM_ACCELERATION = 0.0015;
    let platformSpeed = PLATFORM_SPEED_INITIAL;


    // --- LÓGICA DE CONEXÃO (PEERJS) ---
    function initializeHost() {
        isHost = true;
        if (peer) peer.destroy();
        statusP.textContent = 'Iniciando...';
        peer = new Peer();
        peer.on('open', id => {
            statusP.textContent = 'Aguardando conexão do amigo...';
            myPeerIdSpan.textContent = id;
            getHostIdBtn.disabled = true;
            copyIdBtn.classList.remove('hidden');
        });
        peer.on('connection', setupConnection);
        peer.on('error', err => { 
            statusP.innerHTML = `Erro de conexão: ${err.type}. <br> Por favor, recarregue a página e tente novamente.`;
        });
    }

    function connectToPeer() {
        isHost = false;
        const hostId = otherPeerIdInput.value.trim();
        if (!hostId) { alert('Insira o ID do Host.'); return; }
        if (peer) peer.destroy();
        peer = new Peer();
        peer.on('open', () => {
            statusP.textContent = `Tentando conectar ao Host: ${hostId}...`;
            const newConnection = peer.connect(hostId, { reliable: true });
            setupConnection(newConnection);
        });
        peer.on('error', err => {
            statusP.innerHTML = `Erro: ${err.type}. <br>Verifique o ID ou tente novamente.`;
        });
    }

    function setupConnection(newConnection) {
        if (conn) conn.close();
        conn = newConnection;
        conn.on('open', () => {
            statusP.textContent = `Conectado a: ${conn.peer}`;
            connectionSetupDiv.classList.add('hidden');
            gameAreaDiv.classList.remove('hidden');
            if (isHost) {
                initGame();
            }
        });
        conn.on('data', handleData);
        conn.on('close', resetToLobby);
    }
    
    function handleData(data) {
        switch (data.type) {
            case 'init':
                platforms = data.platforms;
                initGame(false);
                break;
            case 'new_plats':
                platforms.push(...data.platforms);
                break;
            case 'pos':
                friend.x = data.x;
                friend.y = data.y;
                friend.alive = data.alive;
                friend.score = data.score;
                break;
            case 'dead':
                friend.alive = false;
                if (player.alive) endGame(true);
                break;
        }
    }
    
    function resetToLobby() {
        statusP.textContent = 'Conexão perdida.';
        gameAreaDiv.classList.add('hidden');
        connectionSetupDiv.classList.remove('hidden');
        getHostIdBtn.disabled = false;
        copyIdBtn.classList.add('hidden');
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
    }
    
    // --- LÓGICA DO JOGO ---
    function addPlatforms(startY, numPlatforms) {
        const newPlats = [];
        const halfWidth = canvas.width / 2;
        const platWidth = 60;
        let currentY = startY;
        const margin = 30;

        for (let i = 0; i < numPlatforms; i++) {
            const platYLeft = currentY + (Math.random() * 60 - 30);
            const platYRight = currentY + (Math.random() * 60 - 30);
            
            newPlats.push({
                x: Math.random() * (halfWidth - platWidth - margin * 2) + margin,
                y: platYLeft, width: platWidth, height: 20,
                type: Math.random() < 0.3 ? 'breakable' : 'normal'
            });
            newPlats.push({
                x: halfWidth + Math.random() * (halfWidth - platWidth - margin * 2) + margin,
                y: platYRight, width: platWidth, height: 20,
                type: Math.random() < 0.3 ? 'breakable' : 'normal'
            });
            
            currentY += 120;
        }
        return newPlats;
    }


    function initGame(isInitiator = true) {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = 500;

        gameOver = false;
        gameRunning = false;
        platformSpeed = PLATFORM_SPEED_INITIAL;
        gameMessage.textContent = '';
        endGameButtonsDiv.innerHTML = '';

        const halfWidth = canvas.width / 2;
        const startX_P1 = (halfWidth / 2) - (PLAYER_WIDTH / 2);
        const startX_P2 = halfWidth + (halfWidth / 2) - (PLAYER_WIDTH / 2);

        player = { x: isHost ? startX_P1 : startX_P2, y: 50, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, color: isHost ? 'royalblue' : 'tomato', alive: true, score: 0 };
        friend = { x: isHost ? startX_P2 : startX_P1, y: 50, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, color: isHost ? 'tomato' : 'royalblue', alive: true, score: 0 };
        
        if (isInitiator) {
            platforms = addPlatforms(canvas.height, 20);
            conn.send({ type: 'init', platforms: platforms });
        }
        
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        
        let count = 3;
        countdownOverlay.style.display = 'flex';
        countdownOverlay.textContent = count;
        
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                countdownOverlay.textContent = count;
            } else {
                clearInterval(countdownInterval);
                countdownOverlay.textContent = 'VAI!';
                setTimeout(() => {
                    countdownOverlay.style.display = 'none';
                    gameRunning = true;
                    gameLoop();
                }, 500);
            }
        }, 1000);
    }

    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.key] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });

    function update() {
        if (gameOver || !gameRunning) return;
        
        platformSpeed += PLATFORM_ACCELERATION;
        platforms.forEach(p => {
            if (p.breakTimer > 0) {
                p.breakTimer--;
                if (p.breakTimer === 0) {
                    p.toBeRemoved = true;
                }
            }
            p.y -= platformSpeed;
        });

        // **FIX:** Lógica de geração infinita corrigida e robusta
        if (isHost) {
            let currentLowestY = 0;
            for (const p of platforms) {
                if (p.y > currentLowestY) {
                    currentLowestY = p.y;
                }
            }
            if (currentLowestY < canvas.height + 200) {
                const newPlats = addPlatforms(currentLowestY + 120, 10);
                platforms.push(...newPlats);
                conn.send({ type: 'new_plats', platforms: newPlats });
            }
        }
        platforms = platforms.filter(p => p.y + p.height > 0 && !p.toBeRemoved);

        if (keys['ArrowLeft']) player.x -= PLAYER_SPEED;
        if (keys['ArrowRight']) player.x += PLAYER_SPEED;
        if ((keys['ArrowUp'] || keys[' ']) && player.onGround) {
            player.vy = JUMP_FORCE;
            player.onGround = false;
        }

        player.vy += GRAVITY;
        player.y += player.vy;
        player.onGround = false;

        platforms.forEach(plat => {
            if (player.x < plat.x + plat.width && player.x + player.width > plat.x &&
                player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy) {
                if (player.vy >= 0) {
                    player.onGround = true;
                    player.y = plat.y - player.height;
                    player.vy = 0;
                    if (plat.type === 'breakable' && !plat.breakTimer) {
                        plat.breakTimer = 30; // Começa a quebrar (0.5s)
                    }
                }
            }
        });
        
        if (player.onGround) {
            player.y -= platformSpeed;
        }
        
        const halfWidth = canvas.width / 2;
        const margin = 5;
        if (isHost) {
            if (player.x < margin) player.x = margin;
            if (player.x + player.width > halfWidth - margin) player.x = halfWidth - player.width - margin;
        } else {
            if (player.x < halfWidth + margin) player.x = halfWidth + margin;
            if (player.x + player.width > canvas.width - margin) player.x = canvas.width - player.width - margin;
        }

        player.score = Math.max(player.score, Math.floor(player.y));

        if (player.y + player.height < 0 || player.y > canvas.height) {
            player.alive = false;
            conn.send({ type: 'dead' });
            endGame(false);
        }

        if (conn && conn.open) {
            conn.send({ type: 'pos', x: player.x, y: player.y, alive: player.alive, score: player.score });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = 'rgba(255, 50, 50, 0.2)';
        ctx.fillRect(0, 0, canvas.width, 30);

        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();

        platforms.forEach(plat => {
            if (plat.type === 'breakable') {
                ctx.fillStyle = '#a0522d'; // Marrom para quebrável
            } else {
                ctx.fillStyle = '#63b3ed'; // Azul para normal
            }
            let platX = plat.x;
            if (plat.breakTimer > 0) {
                platX += Math.sin(plat.breakTimer * 0.5) * 3;
            }
            ctx.fillRect(platX, plat.y, plat.width, plat.height);
        });

        if (player.alive) {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
        
        if (friend.alive) {
            ctx.fillStyle = friend.color;
            ctx.fillRect(friend.x, friend.y, friend.width, friend.height);
        }

        playerScoreHud.textContent = `P1: ${player.score}`;
        friendScoreHud.textContent = `P2: ${friend.score}`;
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function endGame(iWon) {
        if (gameOver) return;
        gameOver = true;
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        
        const myFinalScore = player.score;
        const friendFinalScore = friend.score;
        let winnerText = '';

        if (iWon) {
            winnerText = "VOCÊ VENCEU!";
        } else if (!player.alive && !friend.alive) {
            if (myFinalScore > friendFinalScore) {
                winnerText = "VOCÊ VENCEU PELA PONTUAÇÃO!";
            } else if (friendFinalScore > myFinalScore) {
                winnerText = "VOCÊ PERDEU PELA PONTUAÇÃO!";
            } else {
                winnerText = "EMPATE!";
            }
        } else {
            winnerText = "Você perdeu...";
        }

        gameMessage.textContent = winnerText;
        gameMessage.style.color = (iWon || myFinalScore > friendFinalScore) ? '#48bb78' : '#f56565';
        
        endGameButtonsDiv.innerHTML = '';
        if(isHost) {
            endGameButtonsDiv.appendChild(playAgainBtn);
        }
    }

    // --- EVENT LISTENERS ---
    getHostIdBtn.addEventListener('click', initializeHost);
    connectToHostBtn.addEventListener('click', connectToPeer);
    playAgainBtn.addEventListener('click', () => {
        initGame(true);
    });
    copyIdBtn.addEventListener('click', () => {
        const id = myPeerIdSpan.textContent;
        navigator.clipboard.writeText(id).then(() => {
            const feedback = document.createElement('div');
            feedback.textContent = 'Copiado!';
            feedback.className = 'copied-feedback';
            copyIdBtn.parentElement.appendChild(feedback);
            setTimeout(() => {
                feedback.remove();
            }, 2000);
        }).catch(err => console.error('Erro ao copiar ID: ', err));
    });
    </script>
</body>
</html>
